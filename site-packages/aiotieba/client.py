import asyncio
import socket
from typing import Optional, Union

import aiohttp
import yarl

from .api import (
    get_ats,
    get_comments,
    get_fid,
    get_forum,
    get_forum_detail,
    get_images,
    get_posts,
    get_replys,
    get_tab_map,
    get_threads,
    get_uinfo_getuserinfo_app,
    get_uinfo_getUserInfo_web,
    get_uinfo_panel,
    get_uinfo_user_json,
    init_z_id,
    login,
    profile,
    tieba_uid2user_info,
)
from .api._classdef import UserInfo
from .config import ProxyConfig, TimeoutConfig
from .core import Account, HttpCore, NetCore, WsCore
from .enums import (
    GroupType,
    PostSortType,
    ReqUInfo,
    ThreadSortType,
    WsStatus,
)
from .exception import BoolResponse, IntResponse, StrResponse
from .helper.cache import ForumInfoCache
from .helper.utils import handle_exception, is_portrait, is_user_name
from .logging import get_logger as LOG


def _try_websocket(func):
    async def awrapper(self: "Client", *args, **kwargs):
        if self._try_ws:
            await self.init_websocket()
        return await func(self, *args, **kwargs)

    awrapper.__name__ = func.__name__

    return awrapper


class Client:
    """
    贴吧客户端

    Args:
        BDUSS (str, optional): BDUSS. Defaults to ''.
        STOKEN (str, optional): STOKEN. Defaults to ''.
        account (Account, optional): Account实例 该字段会覆盖前两个参数. Defaults to None.
        try_ws (bool, optional): 尝试使用websocket接口. Defaults to False.
        proxy (bool | ProxyConfig, optional): True则使用环境变量代理 False则禁用代理 输入ProxyConfig实例以手动配置代理. Defaults to False.
        timeout (TimeoutConfig, optional): 超时配置. Defaults to None.
        loop (asyncio.AbstractEventLoop, optional): 事件循环. Defaults to None.
    """

    __slots__ = [
        '_connector',
        '_http_core',
        '_ws_core',
        '_try_ws',
        '_user',
    ]

    def __init__(
        self,
        BDUSS: str = '',
        STOKEN: str = '',
        *,
        account: Optional[Account] = None,
        try_ws: bool = False,
        proxy: Union[bool, ProxyConfig] = False,
        timeout: Optional[TimeoutConfig] = None,
        loop: Optional[asyncio.AbstractEventLoop] = None,
    ) -> None:
        if loop is None:
            loop = asyncio.get_running_loop()

        if not isinstance(timeout, TimeoutConfig):
            timeout = TimeoutConfig()

        connector = aiohttp.TCPConnector(
            ttl_dns_cache=timeout.dns_ttl,
            family=socket.AF_INET,
            keepalive_timeout=timeout.http_keepalive,
            limit=0,
            ssl=False,
            loop=loop,
        )
        self._connector = connector

        if proxy is True:
            proxy = ProxyConfig.from_env()
        elif not proxy:
            proxy = ProxyConfig()

        if not isinstance(account, Account):
            account = Account(BDUSS, STOKEN)

        net_core = NetCore(connector, proxy, timeout)
        self._http_core = HttpCore(account, net_core, loop)
        self._ws_core = WsCore(account, net_core, loop)

        self._try_ws = try_ws

        self._user = UserInfo()

    async def __aenter__(self) -> "Client":
        return self

    async def __aexit__(self, exc_type=None, exc_val=None, exc_tb=None) -> None:
        await self._ws_core.close()
        await self._connector.close()

    def __hash__(self) -> int:
        return hash(self.account)

    def __eq__(self, obj: "Client") -> bool:
        return self.account == obj.account

    @property
    def account(self) -> Account:
        return self._http_core.account

    @account.setter
    def account(self, new_account: Account) -> None:
        self._http_core.set_account(new_account)
        self._ws_core.set_account(new_account)

    @handle_exception(BoolResponse)
    async def init_websocket(self) -> BoolResponse:
        """
        初始化websocket

        Returns:
            BoolResponse: True无须执行 False失败
        """

        if self._ws_core.status == WsStatus.CLOSED:
            try:
                await self._ws_core.connect()
                await self.__upload_sec_key()
            except BaseException:
                self._ws_core._status = WsStatus.CLOSED
                raise

        return BoolResponse()

    async def __upload_sec_key(self) -> None:
        from .api import init_websocket
        from .core.websocket import MsgIDPair

        groups = await init_websocket.request(self._ws_core)

        mid_manager = self._ws_core.mid_manager
        for group in groups:
            if group.group_type == GroupType.PRIVATE_MSG:
                mid_manager.priv_gid = group.group_id
        mid_manager.gid2mid = {g.group_id: MsgIDPair(g.last_msg_id, g.last_msg_id) for g in groups}

        self._ws_core._status = WsStatus.OPEN


    async def __login(self) -> None:
        user, tbs = await login.request(self._http_core)

        self._user |= user
        self.account.tbs = tbs

        z_id = await init_z_id.request(self._http_core)
        self.account.z_id = z_id

    @handle_exception(get_forum.Forum)
    async def get_forum(self, fname_or_fid: Union[str, int]) -> get_forum.Forum:
        """
        通过forum_id获取贴吧信息
        此接口较`get_forum_detail`更强大

        Args:
            fname_or_fid (str | int): 目标贴吧名或fid 优先贴吧名

        Returns:
            Forum: 贴吧信息
        """

        fname = fname_or_fid if isinstance(fname_or_fid, str) else await self.__get_fname(fname_or_fid)

        return await get_forum.request(self._http_core, fname)

    @handle_exception(get_forum_detail.Forum_detail)
    @_try_websocket
    async def get_forum_detail(self, fname_or_fid: Union[str, int]) -> get_forum_detail.Forum_detail:
        """
        通过forum_id获取贴吧信息

        Args:
            fname_or_fid (str | int): 目标贴吧名或fid 优先fid

        Returns:
            Forum_detail: 贴吧信息
        """

        fid = fname_or_fid if isinstance(fname_or_fid, int) else await self.__get_fid(fname_or_fid)

        if self._ws_core.status == WsStatus.OPEN:
            return await get_forum_detail.request_ws(self._ws_core, fid)

        return await get_forum_detail.request_http(self._http_core, fid)

    async def __get_fid(self, fname: str) -> int:
        if fid := ForumInfoCache.get_fid(fname):
            return fid

        fid = await get_fid.request(self._http_core, fname)
        ForumInfoCache.add_forum(fname, fid)

        return fid

    @handle_exception(IntResponse)
    async def get_fid(self, fname: str) -> IntResponse:
        """
        通过贴吧名获取forum_id

        Args:
            fname (str): 贴吧名

        Returns:
            IntResponse: forum_id
        """

        fid = await self.__get_fid(fname)
        return IntResponse(fid)

    async def __get_fname(self, fid: int) -> str:
        if fname := ForumInfoCache.get_fname(fid):
            return fname

        fdetail = await self.get_forum_detail(fid)
        fname = fdetail.fname

        if fname:
            ForumInfoCache.add_forum(fname, fid)

        return fname

    @handle_exception(StrResponse)
    async def get_fname(self, fid: int) -> StrResponse:
        """
        通过forum_id获取贴吧名

        Args:
            fid (int): forum_id

        Returns:
            StrResponse: 贴吧名
        """

        fname = await self.__get_fname(fid)
        return StrResponse(fname)

    @handle_exception(get_threads.Threads)
    @_try_websocket
    async def get_threads(
        self,
        fname_or_fid: Union[str, int],
        /,
        pn: int = 1,
        *,
        rn: int = 30,
        sort: ThreadSortType = ThreadSortType.REPLY,
        is_good: bool = False,
    ) -> get_threads.Threads:
        """
        获取首页帖子

        Args:
            fname_or_fid (str | int): 贴吧名或fid 优先贴吧名
            pn (int, optional): 页码. Defaults to 1.
            rn (int, optional): 请求的条目数. Defaults to 30. Max to 100.
            sort (ThreadSortType, optional): HOT热门排序 REPLY按回复时间 CREATE按发布时间 FOLLOW关注的人. Defaults to ThreadSortType.REPLY.
            is_good (bool, optional): True则获取精品区帖子 False则获取普通区帖子. Defaults to False.

        Returns:
            Threads: 帖子列表
        """

        fname = fname_or_fid if isinstance(fname_or_fid, str) else await self.__get_fname(fname_or_fid)

        if self._ws_core.status == WsStatus.OPEN:
            return await get_threads.request_ws(self._ws_core, fname, pn, rn, sort, is_good)

        return await get_threads.request_http(self._http_core, fname, pn, rn, sort, is_good)

    @handle_exception(get_posts.Posts)
    @_try_websocket
    async def get_posts(
        self,
        tid: int,
        /,
        pn: int = 1,
        *,
        rn: int = 30,
        sort: PostSortType = PostSortType.ASC,
        only_thread_author: bool = False,
        with_comments: bool = False,
        comment_sort_by_agree: bool = True,
        comment_rn: int = 4,
    ) -> get_posts.Posts:
        """
        获取主题帖内回复

        Args:
            tid (int): 所在主题帖tid
            pn (int, optional): 页码. Defaults to 1.
            rn (int, optional): 请求的条目数. Defaults to 30.
            sort (PostSortType, optional): ASC时间顺序 DESC时间倒序 HOT热门序. Defaults to PostSortType.ASC.
            only_thread_author (bool, optional): True则只看楼主 False则请求全部. Defaults to False.
            with_comments (bool, optional): True则同时请求高赞楼中楼 False则返回的Post.comments字段为空. Defaults to False.
            comment_sort_by_agree (bool, optional): True则楼中楼按点赞数顺序 False则楼中楼按时间顺序. Defaults to True.
            comment_rn (int, optional): 请求的楼中楼数量. Defaults to 4. Max to 50.

        Returns:
            Posts: 回复列表
        """

        if self._ws_core.status == WsStatus.OPEN:
            return await get_posts.request_ws(
                self._ws_core, tid, pn, rn, sort, only_thread_author, with_comments, comment_sort_by_agree, comment_rn
            )

        return await get_posts.request_http(
            self._http_core, tid, pn, rn, sort, only_thread_author, with_comments, comment_sort_by_agree, comment_rn
        )

    @handle_exception(get_comments.Comments)
    @_try_websocket
    async def get_comments(
        self, tid: int, pid: int, /, pn: int = 1, *, is_comment: bool = False
    ) -> get_comments.Comments:
        """
        获取楼中楼回复

        Args:
            tid (int): 所在主题帖tid
            pid (int): 所在楼层的pid或楼中楼的pid
            pn (int, optional): 页码. Defaults to 1.
            is_comment (bool, optional): pid是否指向楼中楼 若指向楼中楼则获取其附近的楼中楼列表. Defaults to False.

        Returns:
            Comments: 楼中楼列表
        """

        if self._ws_core.status == WsStatus.OPEN:
            return await get_comments.request_ws(self._ws_core, tid, pid, pn, is_comment)

        return await get_comments.request_http(self._http_core, tid, pid, pn, is_comment)

    @handle_exception(profile.UserInfo_pf)
    @_try_websocket
    async def _get_uinfo_profile(self, uid_or_portrait: Union[str, int]) -> profile.UserInfo_pf:
        """
        接口 https://tiebac.baidu.com/c/u/user/profile

        Args:
            uid_or_portrait (str | int): 用户id user_id / portrait

        Returns:
            UserInfo_pf: 包含最全面的用户信息
        """

        if self._ws_core.status == WsStatus.OPEN:
            return await profile.get_uinfo_profile.request_ws(self._ws_core, uid_or_portrait)

        return await profile.get_uinfo_profile.request_http(self._http_core, uid_or_portrait)

    @handle_exception(get_uinfo_getuserinfo_app.UserInfo_guinfo_app)
    @_try_websocket
    async def _get_uinfo_getuserinfo(self, user_id: int) -> get_uinfo_getuserinfo_app.UserInfo_guinfo_app:
        """
        接口 https://tiebac.baidu.com/c/u/user/getuserinfo

        Args:
            user_id (int): 用户id user_id

        Returns:
            UserInfo_guinfo_app: 包含 user_id / portrait / user_name / nick_name_old / 性别 /
                是否大神 / 是否超级会员
        """

        if self._ws_core.status == WsStatus.OPEN:
            user = await get_uinfo_getuserinfo_app.request_ws(self._ws_core, user_id)

        else:
            user = await get_uinfo_getuserinfo_app.request_http(self._http_core, user_id)
            if (user_id := user.user_id) < 0:
                user.user_id = 0xFFFFFFFF + user_id

        return user

    @handle_exception(get_uinfo_getUserInfo_web.UserInfo_guinfo_web)
    async def _get_uinfo_getUserInfo(self, user_id: int) -> get_uinfo_getUserInfo_web.UserInfo_guinfo_web:
        """
        接口 http://tieba.baidu.com/im/pcmsg/query/getUserInfo

        Args:
            user_id (int): 用户id user_id

        Returns:
            UserInfo_guinfo_web: 包含 user_id / portrait / user_name / nick_name_new

        Note:
            该接口需要BDUSS
        """

        user = await get_uinfo_getUserInfo_web.request(self._http_core, user_id)
        user.user_id = user_id

        return user

    @handle_exception(get_uinfo_user_json.UserInfo_json)
    async def _get_uinfo_user_json(self, user_name: str) -> get_uinfo_user_json.UserInfo_json:
        """
        接口 http://tieba.baidu.com/i/sys/user_json

        Args:
            user_name (str): 用户id user_name

        Returns:
            UserInfo_json: 包含 user_id / portrait / user_name
        """

        user = await get_uinfo_user_json.request(self._http_core, user_name)
        user.user_name = user_name

        return user

    @handle_exception(get_uinfo_panel.UserInfo_panel)
    async def _get_uinfo_panel(self, name_or_portrait: str) -> get_uinfo_panel.UserInfo_panel:
        """
        接口 https://tieba.baidu.com/home/get/panel

        Args:
            name_or_portrait (str): 用户id user_name / portrait

        Returns:
            UserInfo_panel: 包含较全面的用户信息

        Note:
            从2022.08.30开始服务端不再返回user_id字段 请谨慎使用\n
            该接口可判断用户是否被屏蔽\n
            该接口rps阈值较低
        """

        return await get_uinfo_panel.request(self._http_core, name_or_portrait)

    async def get_user_info(self, id_: Union[str, int], /, require: ReqUInfo = ReqUInfo.ALL) -> UserInfo:
        """
        获取用户信息

        Args:
            id_ (str | int): 用户id user_id / portrait / user_name
            require (ReqUInfo): 指示需要获取的字段

        Returns:
            UserInfo: 用户信息
        """

        if not id_:
            LOG().warning("Null input")
            return UserInfo()

        if isinstance(id_, int):
            if (require | ReqUInfo.BASIC) == ReqUInfo.BASIC:
                # 仅有BASIC需求
                return await self._get_uinfo_getuserinfo(id_)
            else:
                return await self._get_uinfo_profile(id_)
        elif is_portrait(id_):
            if (require | ReqUInfo.BASIC) == ReqUInfo.BASIC:
                # 仅有BASIC需求
                if not require & ReqUInfo.USER_ID:
                    # 无USER_ID需求
                    return await self._get_uinfo_panel(id_)
            return await self._get_uinfo_profile(id_)
        else:
            if (require | ReqUInfo.BASIC) == ReqUInfo.BASIC:
                return await self._get_uinfo_user_json(id_)
            elif require & ReqUInfo.NICK_NAME and not require & ReqUInfo.USER_ID:
                # 有NICK_NAME需求但无USER_ID需求
                return await self._get_uinfo_panel(id_)
            else:
                user = await self._get_uinfo_user_json(id_)
                return await self._get_uinfo_profile(user.portrait)

    @handle_exception(tieba_uid2user_info.UserInfo_TUid)
    @_try_websocket
    async def tieba_uid2user_info(self, tieba_uid: int) -> tieba_uid2user_info.UserInfo_TUid:
        """
        通过tieba_uid获取用户信息

        Args:
            tieba_uid (int): 用户id tieba_uid

        Returns:
            UserInfo_TUid: 包含较全面的用户信息

        Note:
            请注意tieba_uid与旧版user_id的区别
        """

        if self._ws_core.status == WsStatus.OPEN:
            return await tieba_uid2user_info.request_ws(self._ws_core, tieba_uid)

        return await tieba_uid2user_info.request_http(self._http_core, tieba_uid)

    @handle_exception(profile.Homepage)
    @_try_websocket
    async def get_homepage(self, id_: Union[str, int], /, pn: int = 1) -> profile.Homepage:
        """
        获取用户个人页信息

        Args:
            id_ (str | int): 用户id user_id / user_name / portrait 优先user_id
            pn (int, optional): 页码. Defaults to 1.

        Returns:
            Homepage: 用户个人页信息
        """

        if not isinstance(id_, int):
            user = await self.get_user_info(id_, ReqUInfo.USER_ID)
            user_id = user.user_id
        else:
            user_id = id_

        if self._ws_core.status == WsStatus.OPEN:
            return await profile.get_homepage.request_ws(self._ws_core, user_id, pn)

        return await profile.get_homepage.request_http(self._http_core, user_id, pn)

    @handle_exception(get_replys.Replys)
    @_try_websocket
    async def get_replys(self, pn: int = 1) -> get_replys.Replys:
        """
        获取回复信息

        Args:
            pn (int, optional): 页码. Defaults to 1.

        Returns:
            Replys: 回复列表
        """

        if self._ws_core.status == WsStatus.OPEN:
            return await get_replys.request_ws(self._ws_core, pn)

        return await get_replys.request_http(self._http_core, pn)

    @handle_exception(get_ats.Ats)
    async def get_ats(self, pn: int = 1) -> get_ats.Ats:
        """
        获取@信息

        Args:
            pn (int, optional): 页码. Defaults to 1.

        Returns:
            Ats: at列表
        """

        return await get_ats.request(self._http_core, pn)

    @handle_exception(get_images.ImageBytes)
    async def get_image_bytes(self, img_url: str) -> get_images.ImageBytes:
        """
        从链接获取静态图像的原始字节流

        Args:
            img_url (str): 图像链接

        Returns:
            ImageBytes: 未解码的原始字节流
        """

        return await get_images.request_bytes(self._http_core, yarl.URL(img_url))

    @handle_exception(get_tab_map.TabMap)
    @_try_websocket
    async def get_tab_map(self, fname_or_fid: Union[str, int]) -> get_tab_map.TabMap:
        """
        获取分区名到分区id的映射

        Args:
            fname_or_fid (str | int): 目标贴吧名或fid 优先贴吧名

        Returns:
            TabMap: 分区名到分区id的映射
        """

        fname = fname_or_fid if isinstance(fname_or_fid, str) else await self.__get_fname(fname_or_fid)

        if self._ws_core.status == WsStatus.OPEN:
            return await get_tab_map.request_ws(self._ws_core, fname)

        return await get_tab_map.request_http(self._http_core, fname)
